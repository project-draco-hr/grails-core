{
  final ClassPathBeanDefinitionScanner scanner=super.configureScanner(parserContext,element);
  final PathMatchingResourcePatternResolver resourceResolver=new PathMatchingResourcePatternResolver(parserContext.getReaderContext().getResourceLoader()){
    @Override protected Resource[] findAllClassPathResources(    String location) throws IOException {
      Set<Resource> result=new LinkedHashSet<Resource>(16);
      URL classesDir=null;
      final boolean warDeployed=Metadata.getCurrent().isWarDeployed();
      if (!warDeployed) {
        BuildSettings buildSettings=BuildSettingsHolder.getSettings();
        if (buildSettings != null && buildSettings.getClassesDir() != null) {
          classesDir=buildSettings.getClassesDir().toURI().toURL();
        }
      }
      String path=location;
      if (path.startsWith("/")) {
        path=path.substring(1);
      }
      Enumeration resourceUrls=getClassLoader().getResources(path);
      while (resourceUrls.hasMoreElements()) {
        URL url=(URL)resourceUrls.nextElement();
        if (!warDeployed && classesDir != null && url.equals(classesDir)) {
          result.add(convertClassLoaderURL(url));
        }
 else         if (warDeployed) {
          result.add(convertClassLoaderURL(url));
        }
      }
      return result.toArray(new Resource[result.size()]);
    }
  }
;
  resourceResolver.setPathMatcher(new AntPathMatcher(){
    @Override public boolean match(    String pattern,    String path){
      if (path.endsWith(".class")) {
        String filename=FilenameUtils.getBaseName(path);
        if (filename.indexOf("$") > -1)         return false;
      }
      return super.match(pattern,path);
    }
  }
);
  scanner.setResourceLoader(resourceResolver);
  return scanner;
}
