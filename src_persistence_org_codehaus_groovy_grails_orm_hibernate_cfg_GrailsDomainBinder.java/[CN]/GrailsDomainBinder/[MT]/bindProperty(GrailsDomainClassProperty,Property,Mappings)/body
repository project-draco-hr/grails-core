{
  prop.setName(grailsProperty.getName());
  prop.setInsertable(true);
  prop.setUpdateable(true);
  prop.setPropertyAccessorName(mappings.getDefaultAccess());
  prop.setOptional(grailsProperty.isOptional());
  if (grailsProperty.isAssociation()) {
    if (grailsProperty.isOneToMany()) {
      if (!grailsProperty.isBidirectional()) {
        if (grailsProperty.isOwningSide())         prop.setCascade("all");
 else         prop.setCascade("save-update");
      }
 else       if (grailsProperty.isBidirectional())       prop.setCascade("all");
    }
 else     if (grailsProperty.isManyToMany()) {
      if (grailsProperty.isOwningSide()) {
        prop.setCascade("save-update");
      }
    }
 else     if (grailsProperty.isManyToOne() || grailsProperty.isOneToOne()) {
      GrailsDomainClass domainClass=grailsProperty.getDomainClass();
      System.out.println("grailsProperty.getName() = " + grailsProperty.getName());
      if (domainClass.isOwningClass(grailsProperty.getType())) {
        System.out.println("set cascade to all");
        prop.setCascade("all");
      }
 else {
        GrailsDomainClassProperty otherSide=grailsProperty.getOtherSide();
        System.out.println("otherSide = " + otherSide);
        if (otherSide != null && otherSide.isOneToMany()) {
          System.out.println("set cascade to merge");
          prop.setCascade("merge");
        }
 else         if (grailsProperty.isOwningSide()) {
          System.out.println("set cascade to all");
          prop.setCascade("all");
        }
      }
    }
  }
 else   if (Map.class.isAssignableFrom(grailsProperty.getType())) {
    prop.setCascade("all");
  }
  if (LOG.isTraceEnabled())   LOG.trace("[GrailsDomainBinder] Set cascading strategy on property [" + grailsProperty.getName() + "] to ["+ prop.getCascade()+ "]");
  prop.setLazy(true);
}
