{
  final DeclarationExpression declareCoExpression=new DeclarationExpression(new VariableExpression(paramName,commandObjectNode),Token.newSymbol(Types.EQUALS,0,0),new EmptyExpression());
  wrapper.addStatement(new ExpressionStatement(declareCoExpression));
  final Statement constructWithJsonBlock=getStatementToInitializeCommandObjectWithJson(commandObjectNode,paramName);
  final Statement constructWithXmlBlock=getStatementToInitializeCommandObjectWithXml(commandObjectNode,paramName);
  final Statement constructAndBindParamsBlock=getStatementToInitializeCommandObject(commandObjectNode,paramName);
  final Expression contentTypeExpression=new PropertyExpression(new VariableExpression("request"),"contentType");
  final Expression isApplicationJsonRequestExpression=new BinaryExpression(contentTypeExpression,Token.newSymbol(Types.COMPARE_EQUAL,0,0),new ConstantExpression("application/json"));
  final Expression isTextJsonRequestExpression=new BinaryExpression(contentTypeExpression,Token.newSymbol(Types.COMPARE_EQUAL,0,0),new ConstantExpression("text/json"));
  final Expression isJsonRequestExpression=new BinaryExpression(isApplicationJsonRequestExpression,Token.newSymbol(Types.LOGICAL_OR,0,0),isTextJsonRequestExpression);
  final Expression isApplicationXmlRequestExpression=new BinaryExpression(contentTypeExpression,Token.newSymbol(Types.COMPARE_EQUAL,0,0),new ConstantExpression("application/xml"));
  final Expression isTextXmlRequestExpression=new BinaryExpression(contentTypeExpression,Token.newSymbol(Types.COMPARE_EQUAL,0,0),new ConstantExpression("text/xml"));
  final Expression isXmlRequestExpression=new BinaryExpression(isApplicationXmlRequestExpression,Token.newSymbol(Types.LOGICAL_OR,0,0),isTextXmlRequestExpression);
  final Statement isJsonRequestStatement=new IfStatement(new BooleanExpression(isJsonRequestExpression),constructWithJsonBlock,new IfStatement(new BooleanExpression(isXmlRequestExpression),constructWithXmlBlock,constructAndBindParamsBlock));
  wrapper.addStatement(isJsonRequestStatement);
  final Statement autoWireCommandObjectStatement=getAutoWireCommandObjectStatement(paramName);
  wrapper.addStatement(autoWireCommandObjectStatement);
  @SuppressWarnings("unchecked") boolean argumentIsValidateable=GrailsASTUtils.hasAnyAnnotations(commandObjectNode,grails.validation.Validateable.class,org.codehaus.groovy.grails.validation.Validateable.class,grails.persistence.Entity.class,javax.persistence.Entity.class);
  if (!argumentIsValidateable) {
    final ModuleNode commandObjectModule=commandObjectNode.getModule();
    if (commandObjectModule != null) {
      if (commandObjectModule == controllerNode.getModule() || doesModulePathIncludeSubstring(commandObjectModule,"grails-app" + File.separator + "controllers"+ File.separator)) {
        final ASTValidateableHelper h=new DefaultASTValidateableHelper();
        h.injectValidateableCode(commandObjectNode);
        argumentIsValidateable=true;
      }
 else       if (doesModulePathIncludeSubstring(commandObjectModule,"grails-app" + File.separator + "domain"+ File.separator)) {
        argumentIsValidateable=true;
      }
    }
  }
  if (argumentIsValidateable) {
    final MethodCallExpression validateMethodCallExpression=new MethodCallExpression(new VariableExpression(paramName),"validate",EMPTY_TUPLE);
    final MethodNode validateMethod=commandObjectNode.getMethod("validate",new Parameter[0]);
    if (validateMethod != null) {
      validateMethodCallExpression.setMethodTarget(validateMethod);
    }
    wrapper.addStatement(new ExpressionStatement(validateMethodCallExpression));
  }
 else {
    final Expression respondsToValidateMethodCallExpression=new MethodCallExpression(new VariableExpression(paramName),"respondsTo",new ArgumentListExpression(new ConstantExpression("validate")));
    final Expression validateMethodCallExpression=new MethodCallExpression(new VariableExpression(paramName),"validate",new ArgumentListExpression());
    final Statement ifRespondsToValidateThenValidateStatement=new IfStatement(new BooleanExpression(respondsToValidateMethodCallExpression),new ExpressionStatement(validateMethodCallExpression),new ExpressionStatement(new EmptyExpression()));
    wrapper.addStatement(ifRespondsToValidateThenValidateStatement);
    final String warningMessage="The [" + actionName + "] action accepts a parameter of type ["+ commandObjectNode.getName()+ "] which has not been marked with @Validateable.  Data binding will still be applied "+ "to this command object but the instance will not be validateable.";
    GrailsASTUtils.warning(source,actionNode,warningMessage);
  }
  new DefaultASTDatabindingHelper().injectDatabindingCode(source,context,commandObjectNode);
}
