{
  if (!Exception.class.isAssignableFrom(exceptionType)) {
    throw new IllegalArgumentException("exceptionType [" + exceptionType.getName() + "] argument must be Exception or a subclass of Exception");
  }
  Method handlerMethod=null;
  final List<ControllerExceptionHandlerMetaData> exceptionHandlerMetaDataInstances=(List<ControllerExceptionHandlerMetaData>)GrailsClassUtils.getStaticFieldValue(controllerInstance.getClass(),ControllerActionTransformer.EXCEPTION_HANDLER_META_DATA_FIELD_NAME);
  if (exceptionHandlerMetaDataInstances != null && exceptionHandlerMetaDataInstances.size() > 0) {
    final List<ControllerExceptionHandlerMetaData> matches=(List<ControllerExceptionHandlerMetaData>)org.apache.commons.collections.CollectionUtils.select(exceptionHandlerMetaDataInstances,new Predicate(){
      @Override public boolean evaluate(      Object object){
        ControllerExceptionHandlerMetaData md=(ControllerExceptionHandlerMetaData)object;
        return md.getExceptionType().isAssignableFrom(exceptionType);
      }
    }
);
    if (matches.size() > 0) {
      ControllerExceptionHandlerMetaData theOne=matches.get(0);
      for (int i=1; i < matches.size(); i++) {
        final ControllerExceptionHandlerMetaData nextMatch=matches.get(i);
        if (theOne.getExceptionType().isAssignableFrom(nextMatch.getExceptionType())) {
          theOne=nextMatch;
        }
      }
      handlerMethod=controllerInstance.getClass().getMethod(theOne.getMethodName(),theOne.getExceptionType());
    }
  }
  return handlerMethod;
}
