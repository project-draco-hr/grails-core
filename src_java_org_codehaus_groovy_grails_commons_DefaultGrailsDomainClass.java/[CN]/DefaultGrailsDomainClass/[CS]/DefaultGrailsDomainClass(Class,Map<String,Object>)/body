{
  super(clazz,"");
  PropertyDescriptor[] propertyDescriptors=getPropertyDescriptors();
  if (!clazz.getSuperclass().equals(GroovyObject.class) && !clazz.getSuperclass().equals(Object.class) && !Modifier.isAbstract(clazz.getSuperclass().getModifiers())) {
    this.root=false;
  }
  this.propertyMap=new LinkedHashMap<String,GrailsDomainClassProperty>();
  this.relationshipMap=getAssociationMap();
  this.embedded=getEmbeddedList();
  this.defaultConstraints=defaultConstraints;
  if (getPropertyOrStaticPropertyOrFieldValue(GrailsDomainClassProperty.MAPPING_STRATEGY,String.class) != null)   this.mappingStrategy=(String)getPropertyOrStaticPropertyOrFieldValue(GrailsDomainClassProperty.MAPPING_STRATEGY,String.class);
  this.mappedBy=(Map)getPropertyOrStaticPropertyOrFieldValue(GrailsDomainClassProperty.MAPPED_BY,Map.class);
  this.hasOneMap=(Map)getPropertyOrStaticPropertyOrFieldValue(GrailsDomainClassProperty.HAS_ONE,Map.class);
  if (hasOneMap == null)   hasOneMap=EMPTY_MAP;
  if (this.mappedBy == null)   this.mappedBy=EMPTY_MAP;
  establishRelationshipOwners();
  populateDomainClassProperties(propertyDescriptors);
  if (this.identifier == null) {
    throw new GrailsDomainException("Identity property not found, but required in domain class [" + getFullName() + "]");
  }
  if (this.version == null) {
    throw new GrailsDomainException("Version property not found, but required in domain class [" + getFullName() + "]");
  }
  this.properties=this.propertyMap.values().toArray(new GrailsDomainClassProperty[this.propertyMap.size()]);
  establishRelationships();
  establishPersistentProperties();
}
