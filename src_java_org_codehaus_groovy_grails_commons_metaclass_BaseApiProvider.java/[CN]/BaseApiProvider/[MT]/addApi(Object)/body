{
  if (apiInstance != null) {
    Class<?> currentClass=apiInstance.getClass();
    while (currentClass != Object.class) {
      final Method[] declaredMethods=currentClass.getDeclaredMethods();
      for (      Method method : declaredMethods) {
        final int modifiers=method.getModifiers();
        if (Modifier.isPublic(modifiers) && !Modifier.isAbstract(modifiers)) {
          if (Modifier.isStatic(modifiers)) {
            staticMethods.add(method);
          }
 else {
            instanceMethods.add(new ReflectionMetaMethod(new CachedMethod(method)){
              @Override public Object invoke(              Object object,              Object[] arguments){
                return super.invoke(apiInstance,ArrayUtils.add(arguments,0,object));
              }
              @Override public CachedClass[] getParameterTypes(){
                final CachedClass[] paramTypes=method.getParameterTypes();
                if (paramTypes.length > 0)                 return (CachedClass[])ArrayUtils.subarray(paramTypes,1,paramTypes.length);
 else                 return paramTypes;
              }
            }
);
          }
        }
      }
      currentClass=currentClass.getSuperclass();
    }
  }
}
