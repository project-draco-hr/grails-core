{
  PersistentClass associatedClass=null;
  if (LOG.isDebugEnabled())   LOG.debug("Mapping collection: " + collection.getRole() + " -> "+ collection.getCollectionTable().getName());
  PropertyConfig propConfig=getPropertyConfig(property);
  if (propConfig != null && !StringUtils.isBlank(propConfig.getSort())) {
    if (!property.isBidirectional() && property.isOneToMany()) {
      throw new GrailsDomainException("Default sort for associations [" + property.getDomainClass().getName() + "->"+ property.getName()+ "] are not supported with unidirectional one to many relationships.");
    }
    GrailsDomainClass referenced=property.getReferencedDomainClass();
    if (referenced != null) {
      GrailsDomainClassProperty propertyToSortBy=referenced.getPropertyByName(propConfig.getSort());
      String associatedClassName=property.getReferencedDomainClass().getFullName();
      associatedClass=(PersistentClass)persistentClasses.get(associatedClassName);
      if (associatedClass != null) {
        collection.setOrderBy(buildOrderByClause(propertyToSortBy.getName(),associatedClass,collection.getRole(),propConfig.getOrder()));
      }
    }
  }
  if (collection.isOneToMany()) {
    GrailsDomainClass referenced=property.getReferencedDomainClass();
    Mapping m=getRootMapping(referenced);
    boolean tablePerSubclass=m != null && !m.getTablePerHierarchy();
    if (referenced != null && !referenced.isRoot() && !tablePerSubclass) {
      Mapping rootMapping=getRootMapping(referenced);
      String discriminatorColumnName=RootClass.DEFAULT_DISCRIMINATOR_COLUMN_NAME;
      if (rootMapping != null) {
        final ColumnConfig discriminatorColumn=rootMapping.getDiscriminatorColumn();
        if (discriminatorColumn != null) {
          discriminatorColumnName=discriminatorColumn.getName();
        }
        if (rootMapping.getDiscriminatorMap().get("formula") != null) {
          discriminatorColumnName=(String)m.getDiscriminatorMap().get("formula");
        }
      }
      Set<String> discSet=buildDiscriminatorSet(referenced);
      String inclause=StringUtils.join(discSet,',');
      collection.setWhere(discriminatorColumnName + " in (" + inclause+ ")");
    }
    OneToMany oneToMany=(OneToMany)collection.getElement();
    String associatedClassName=oneToMany.getReferencedEntityName();
    associatedClass=(PersistentClass)persistentClasses.get(associatedClassName);
    if (associatedClass == null) {
      throw new MappingException("Association references unmapped class: " + oneToMany.getReferencedEntityName());
    }
    oneToMany.setAssociatedClass(associatedClass);
    if (shouldBindCollectionWithForeignKey(property)) {
      collection.setCollectionTable(associatedClass.getTable());
    }
    bindCollectionForPropertyConfig(collection,propConfig);
  }
  if (isSorted(property)) {
    collection.setSorted(true);
  }
  DependantValue key=createPrimaryKeyValue(mappings,property,collection,persistentClasses);
  if (property.isBidirectional()) {
    GrailsDomainClassProperty otherSide=property.getOtherSide();
    if (otherSide.isManyToOne() && shouldBindCollectionWithForeignKey(property)) {
      linkBidirectionalOneToMany(collection,associatedClass,key,otherSide);
    }
 else     if (property.isManyToMany() || Map.class.isAssignableFrom(property.getType())) {
      bindDependentKeyValue(property,key,mappings,sessionFactoryBeanName);
    }
  }
 else {
    if (hasJoinKeyMapping(propConfig)) {
      bindSimpleValue("long",key,false,propConfig.getJoinTable().getKey().getName(),mappings);
    }
 else {
      bindDependentKeyValue(property,key,mappings,sessionFactoryBeanName);
    }
  }
  collection.setKey(key);
  if (propConfig != null) {
    CacheConfig cacheConfig=propConfig.getCache();
    if (cacheConfig != null) {
      collection.setCacheConcurrencyStrategy(cacheConfig.getUsage());
    }
  }
  if (property.isManyToMany() || isBidirectionalOneToManyMap(property)) {
    GrailsDomainClassProperty otherSide=property.getOtherSide();
    if (property.isBidirectional()) {
      if (LOG.isDebugEnabled())       LOG.debug("[GrailsDomainBinder] Mapping other side " + otherSide.getDomainClass().getName() + "."+ otherSide.getName()+ " -> "+ collection.getCollectionTable().getName()+ " as ManyToOne");
      ManyToOne element=new ManyToOne(mappings,collection.getCollectionTable());
      bindManyToMany(otherSide,element,mappings,sessionFactoryBeanName);
      collection.setElement(element);
      bindCollectionForPropertyConfig(collection,propConfig);
      if (property.isCircular()) {
        collection.setInverse(false);
      }
    }
 else {
    }
  }
 else   if (shouldCollectionBindWithJoinColumn(property)) {
    bindCollectionWithJoinTable(property,mappings,collection,propConfig,sessionFactoryBeanName);
  }
 else   if (isUnidirectionalOneToMany(property)) {
    bindUnidirectionalOneToMany(property,mappings,collection);
  }
}
