{
  if (constraints.containsKey(constraintName)) {
    if (MAX_LENGTH_CONSTRAINT.equals(constraintName)) {
      emitDeprecationWarnings(MAX_LENGTH_CONSTRAINT,MAX_SIZE_CONSTRAINT);
      constraintName=MAX_SIZE_CONSTRAINT;
    }
 else     if (MIN_LENGTH_CONSTRAINT.equals(constraintName)) {
      emitDeprecationWarnings(MIN_LENGTH_CONSTRAINT,MIN_SIZE_CONSTRAINT);
      constraintName=MIN_SIZE_CONSTRAINT;
    }
 else     if (LENGTH_CONSTRAINT.equals(constraintName)) {
      emitDeprecationWarnings(LENGTH_CONSTRAINT,SIZE_CONSTRAINT);
      constraintName=SIZE_CONSTRAINT;
    }
    if (constrainingValue == null) {
      this.appliedConstraints.remove(constraintName);
    }
 else {
      try {
        Constraint c=instantiateConstraint(constraintName);
        c.setOwningClass(this.owningClass);
        c.setPropertyName(this.propertyName);
        c.setParameter(constrainingValue);
        this.appliedConstraints.put(constraintName,c);
      }
 catch (      Exception e) {
        LOG.error("Exception thrown applying constraint [" + constraintName + "] to class ["+ owningClass+ "] for value ["+ constrainingValue+ "]: "+ e.getMessage(),e);
        throw new ConstraintException("Exception thrown applying constraint [" + constraintName + "] to class ["+ owningClass+ "] for value ["+ constrainingValue+ "]: "+ e.getMessage());
      }
    }
  }
 else   if (this.bean.isWritableProperty(constraintName)) {
    this.bean.setPropertyValue(constraintName,constrainingValue);
  }
 else {
    throw new ConstraintException("Constraint [" + constraintName + "] is not supported for property ["+ propertyName+ "] of class ["+ owningClass+ "] with type ["+ propertyType+ "]");
  }
}
