{
  PersistentClass associatedClass=null;
  if (LOG.isDebugEnabled())   LOG.debug("Mapping collection: " + collection.getRole() + " -> "+ collection.getCollectionTable().getName());
  PropertyConfig propConfig=getPropertyConfig(property);
  if (propConfig != null && !StringUtils.isBlank(propConfig.getSort())) {
    if (!property.isBidirectional() && property.isOneToMany()) {
      String message="WARNING: Sorting by a child property does " + "not work with unidirectional one to many relationships " + "due to http://opensource.atlassian.com/projects/hibernate/browse/HHH-4394";
      LOG.warn(message);
    }
    GrailsDomainClass referenced=property.getReferencedDomainClass();
    if (referenced != null) {
      GrailsDomainClassProperty propertyToSortBy=referenced.getPropertyByName(propConfig.getSort());
      String columnName=getColumnNameForPropertyAndPath(propertyToSortBy,"",null);
      if (propConfig.getOrder() != null) {
        columnName+=" " + propConfig.getOrder();
      }
      collection.setOrderBy(columnName);
    }
  }
  if (collection.isOneToMany()) {
    GrailsDomainClass referenced=property.getReferencedDomainClass();
    Mapping m=getRootMapping(referenced);
    boolean tablePerSubclass=m != null && !m.getTablePerHierarchy();
    if (referenced != null && !referenced.isRoot() && !tablePerSubclass) {
      Mapping referencedMapping=getMapping(referenced);
      Mapping rootMapping=getRootMapping(referenced);
      String discriminatorColumnName=RootClass.DEFAULT_DISCRIMINATOR_COLUMN_NAME;
      String discriminator=referenced.getFullName();
      if (rootMapping != null) {
        final ColumnConfig discriminatorColumn=rootMapping.getDiscriminatorColumn();
        if (discriminatorColumn != null) {
          discriminatorColumnName=discriminatorColumn.getName();
        }
      }
      if (referencedMapping != null && referencedMapping.getDiscriminator() != null) {
        discriminator=referencedMapping.getDiscriminator();
      }
      collection.setWhere(discriminatorColumnName + " = '" + discriminator+ "'");
    }
    OneToMany oneToMany=(OneToMany)collection.getElement();
    String associatedClassName=oneToMany.getReferencedEntityName();
    associatedClass=(PersistentClass)persistentClasses.get(associatedClassName);
    if (associatedClass == null) {
      throw new MappingException("Association references unmapped class: " + oneToMany.getReferencedEntityName());
    }
    oneToMany.setAssociatedClass(associatedClass);
    if (shouldBindCollectionWithForeignKey(property)) {
      collection.setCollectionTable(associatedClass.getTable());
    }
    bindCollectionForPropertyConfig(collection,propConfig);
  }
  if (isSorted(property)) {
    collection.setSorted(true);
  }
  DependantValue key=createPrimaryKeyValue(property,collection,persistentClasses);
  if (property.isBidirectional()) {
    GrailsDomainClassProperty otherSide=property.getOtherSide();
    if (otherSide.isManyToOne() && shouldBindCollectionWithForeignKey(property)) {
      linkBidirectionalOneToMany(collection,associatedClass,key,otherSide);
    }
 else     if (property.isManyToMany() || Map.class.isAssignableFrom(property.getType())) {
      bindDependentKeyValue(property,key,mappings);
    }
  }
 else {
    if (hasJoinKeyMapping(propConfig)) {
      bindSimpleValue("long",key,false,propConfig.getJoinTable().getKey().getName(),mappings);
    }
 else {
      bindDependentKeyValue(property,key,mappings);
    }
  }
  collection.setKey(key);
  if (propConfig != null) {
    CacheConfig cacheConfig=propConfig.getCache();
    if (cacheConfig != null) {
      collection.setCacheConcurrencyStrategy(cacheConfig.getUsage());
    }
  }
  if (property.isManyToMany() || isBidirectionalOneToManyMap(property)) {
    GrailsDomainClassProperty otherSide=property.getOtherSide();
    if (property.isBidirectional()) {
      if (LOG.isDebugEnabled())       LOG.debug("[GrailsDomainBinder] Mapping other side " + otherSide.getDomainClass().getName() + "."+ otherSide.getName()+ " -> "+ collection.getCollectionTable().getName()+ " as ManyToOne");
      ManyToOne element=new ManyToOne(collection.getCollectionTable());
      bindManyToMany(otherSide,element,mappings);
      collection.setElement(element);
      bindCollectionForPropertyConfig(collection,propConfig);
      if (property.isCircular()) {
        collection.setInverse(false);
      }
    }
 else {
    }
  }
 else   if (shouldCollectionBindWithJoinColumn(property)) {
    bindCollectionWithJoinTable(property,mappings,collection,propConfig);
  }
 else   if (isUnidirectionalOneToMany(property)) {
    bindUnidirectionalOneToMany(property,mappings,collection);
  }
}
