{
  final Expression constructorCallExpression=new ConstructorCallExpression(commandObjectNode,EMPTY_TUPLE);
  final Statement newCommandCode=new ExpressionStatement(new DeclarationExpression(new VariableExpression(paramName,commandObjectNode),Token.newSymbol(Types.EQUALS,0,0),constructorCallExpression));
  wrapper.addStatement(newCommandCode);
  final Statement autoWireCommandObjectStatement=getAutoWireCommandObjectStatement(paramName);
  wrapper.addStatement(autoWireCommandObjectStatement);
  final Statement statement=getCommandObjectDataBindingStatement(controllerNode,paramName,commandObjectNode);
  wrapper.addStatement(statement);
  @SuppressWarnings("unchecked") boolean argumentIsValidateable=GrailsASTUtils.hasAnyAnnotations(commandObjectNode,grails.validation.Validateable.class,org.codehaus.groovy.grails.validation.Validateable.class,grails.persistence.Entity.class,javax.persistence.Entity.class);
  if (!argumentIsValidateable) {
    final ModuleNode commandObjectModule=commandObjectNode.getModule();
    if (commandObjectModule != null) {
      if (commandObjectModule == controllerNode.getModule() || doesModulePathIncludeSubstring(commandObjectModule,"grails-app" + File.separator + "controllers"+ File.separator)) {
        final ASTValidateableHelper h=new DefaultASTValidateableHelper();
        h.injectValidateableCode(commandObjectNode);
        argumentIsValidateable=true;
      }
 else       if (doesModulePathIncludeSubstring(commandObjectModule,"grails-app" + File.separator + "domain"+ File.separator)) {
        argumentIsValidateable=true;
      }
    }
  }
  if (argumentIsValidateable) {
    final MethodCallExpression validateMethodCallExpression=new MethodCallExpression(new VariableExpression(paramName),"validate",EMPTY_TUPLE);
    final MethodNode validateMethod=commandObjectNode.getMethod("validate",new Parameter[0]);
    if (validateMethod != null) {
      validateMethodCallExpression.setMethodTarget(validateMethod);
    }
    wrapper.addStatement(new ExpressionStatement(validateMethodCallExpression));
  }
 else {
    final Expression respondsToValidateMethodCallExpression=new MethodCallExpression(new VariableExpression(paramName),"respondsTo",new ArgumentListExpression(new ConstantExpression("validate")));
    final Expression validateMethodCallExpression=new MethodCallExpression(new VariableExpression(paramName),"validate",new ArgumentListExpression());
    final Statement ifRespondsToValidateThenValidateStatement=new IfStatement(new BooleanExpression(respondsToValidateMethodCallExpression),new ExpressionStatement(validateMethodCallExpression),new ExpressionStatement(new EmptyExpression()));
    wrapper.addStatement(ifRespondsToValidateThenValidateStatement);
    final String warningMessage="The [" + actionName + "] action accepts a parameter of type ["+ commandObjectNode.getName()+ "] which has not been marked with @Validateable.  Data binding will still be applied "+ "to this command object but the instance will not be validateable.";
    GrailsASTUtils.warning(source,actionNode,warningMessage);
  }
}
